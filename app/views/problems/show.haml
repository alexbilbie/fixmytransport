- @title = "#{@problem.location.name}: #{@problem.subject}"
#map-col
  = render :partial => 'shared/map', :locals => { :locations => [@problem.location], :other_locations => [] }
.problem-full
  - if @problem.status == :fixed
    .fixed= t(:problem_has_been_fixed)
  %h2.subject= @title
  .details
    =t(:reported).titleize
    %span.posted-time= t(:posted_time, :time => time_ago_in_words(@problem.confirmed_at))
    %span.author= @problem.anonymous? ? t(:anonymously) : t(:by, :name => @problem.reporter_name)
    %span.transport-location!= t(:problem_location, :link => link_to(@problem.location.description, location_url(@problem.location)))
    - if @problem.sent_at
      .sent-time= t(:sent_time, :interval => distance_of_time_in_words(@problem.sent_at, @problem.confirmed_at), :recipient => @problem.first_sent_to)

  %p.problem= @problem.description
  
  %h3= t(:story_so_far)
  - @problem.assignments.completed.each do |assignment|
    = render :partial => "shared/complete_assignments/#{assignment.task_type}", :locals => { :assignment => assignment }
  - if !@problem.assignments.incomplete.empty? 
    %h3= t(:next_steps)
    - @problem.assignments.incomplete.each do |assignment| 
      = render :partial => "shared/new_assignments/#{assignment.task_type}", :locals => { :assignment => assignment }
%h3= t(:updates)
.updates
  - @problem.updates.confirmed.each do |update| 
    %a{:name => "update_#{update.id}"}
    .details
      = t(:posted)
      %span.posted-time= t(:posted_time, :time => time_ago_in_words(update.confirmed_at))
      %span.author= update.reporter_name.blank? ? t(:anonymously) : t(:by, :name => update.reporter_name)  
      - if update.mark_fixed?
        %span.fixed-text>= ", #{t(:marked_as_fixed)}"
    .update= update.text
  = render :partial => 'update_form'
